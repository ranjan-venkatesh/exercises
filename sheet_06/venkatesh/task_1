#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <stdint.h>
#include <inttypes.h>
#include <sys/time.h>

#define MAX_LINE_LENGTH 1024
#define NUM_TUPLES 10000

static bool readline(char buffer[]);
static int index_of(char str[], char needle[]);
static char * tableContentsTranslator(int i,char result[MAX_LINE_LENGTH]);

struct nsm_lineitem_tuple_t {
    uint32_t orderkey;
    uint32_t partkey;
    uint32_t suppkey;
    int32_t linenumber;
    float quantity;
    float extendedprice;
    float discount;
    float tax;
    char returnflag;
    char linestatus;
    uint64_t shipdate;
    uint64_t commitdate;
    uint64_t receipetdate;
    char shipinstr[25];
    char shipmode[10];
    char comment[44];
};
struct nsm_lineitem_table_t {
    struct nsm_lineitem_tuple_t tuples[NUM_TUPLES];
};

struct nsm_lineitem_table_t nsm_table;


int main(void)
{
    char x[MAX_LINE_LENGTH], n[100],result_tuple[MAX_LINE_LENGTH];
    int n_value;
    int counter=0;
    int iterations=NUM_TUPLES;
    long start, end;

    //Random Generation
    for (unsigned i = 0; i < NUM_TUPLES; i++) {
        nsm_table.tuples[i].orderkey = (uint32_t) (random() % UINT32_MAX);
        nsm_table.tuples[i].partkey = (uint32_t) (random() % UINT32_MAX);
        nsm_table.tuples[i].suppkey = (uint32_t) (random() % UINT32_MAX);
        nsm_table.tuples[i].linenumber = (int32_t) (random() % INT32_MAX);
        nsm_table.tuples[i].quantity = random() % 1000;
        nsm_table.tuples[i].extendedprice = random() % 10000;
        nsm_table.tuples[i].discount = random() % 50 / 100.0f;
        nsm_table.tuples[i].tax = nsm_table.tuples[i].extendedprice * 0.17f;
        nsm_table.tuples[i].returnflag = (char) ('a' + (random() % 26));
        nsm_table.tuples[i].linestatus = (char) ('a' + (random() % 26));
        nsm_table.tuples[i].shipdate = random() % UINT64_MAX;
        nsm_table.tuples[i].commitdate = random() % UINT64_MAX;
        nsm_table.tuples[i].receipetdate = random() % UINT64_MAX;
        for (int j = 0; j < 25; j++) {
            nsm_table.tuples[i].shipinstr[j] = (char) ('a' + (random() % 26));
        }
        for (int j = 0; j < 10; j++) {
            nsm_table.tuples[i].shipmode[j] = (char) ('a' + (random() % 26));
        }
        for (int j = 0; j < 44; j++) {
            nsm_table.tuples[i].comment[j] = (char) ('a' + (random() % 26));
        }
    }




    printf("Type :exit to terminate.\nDatabase Size: %zu MiB\nSELECT orderkey, partkey, suppkey, comment FROM lineitem WHERE comment LIKE %%x%% LIMIT n.\nEnter x:",
           ((sizeof(nsm_table)/1024)/1024));
    while(readline(x)) {
        printf("Enter n:(-1 for no limits)\n");
        if(readline(n)){
            n_value=atoi(n);
            if(n_value!=-1)
                iterations=n_value;

            struct timeval timeval;

            gettimeofday(&timeval, NULL);
            start = (long)timeval.tv_sec * 1000 + (long)timeval.tv_usec / 1000;

            for(int i=0;i<iterations;i++) {
                register bool matches;
counter++;
                matches = (index_of(tableContentsTranslator(i,result_tuple), x) >= 0);
                printf("%s", matches ? tableContentsTranslator(i,result_tuple) : "");
                printf("%s", matches ? "\n" : "");
            }

            gettimeofday(&timeval, NULL);
            end = (long)timeval.tv_sec * 1000 + (long)timeval.tv_usec / 1000;
            printf("%d records in total, %d ms",counter,(end-start));
    }}

    return EXIT_SUCCESS;
}

static char * tableContentsTranslator(int i,char result[MAX_LINE_LENGTH]){

        sprintf(result,"\n %u, %u, %u, %u, %f, %f, %f, %f, %c, %c, %zu , %zu,  %zu, %s, %s, %s\n",nsm_table.tuples[i].orderkey,nsm_table.tuples[i].partkey,nsm_table.tuples[i].suppkey,nsm_table.tuples[i].linenumber,nsm_table.tuples[i].quantity,nsm_table.tuples[i].extendedprice,nsm_table.tuples[i].discount,nsm_table.tuples[i].tax,nsm_table.tuples[i].returnflag,nsm_table.tuples[i].linestatus,nsm_table.tuples[i].shipdate,nsm_table.tuples[i].commitdate,nsm_table.tuples[i].receipetdate,nsm_table.tuples[i].shipinstr,nsm_table.tuples[i].shipmode,nsm_table.tuples[i].comment);


    return result;
}

/*
struct nsm_lineitem_table_t randomLineItemTblData()
{
    struct nsm_lineitem_table_t nsm_table;
    *//* fill with random data *//*

    return nsm_table;
}*/

static bool readline(char buffer[])
{
    printf("$ ");
    fgets(buffer, MAX_LINE_LENGTH, stdin);
    buffer[strcspn(buffer, "\n")] = 0;
    return (strcmp(buffer, ":exit") != 0);
}

static int index_of(char str[], char needle[])
{
    register char str_c, str_scan_c, needle_c;
    register int match_idx;
    register bool match_found;
    for (match_idx = 0, match_found = false;
         str_c = str[match_idx], str_c != '\0' && !match_found;
         match_idx++) {
        for (unsigned j = 0; needle_c = needle[j], str_scan_c = str[match_idx + j],
                str_c == needle[0] && needle_c != '\0' && str_scan_c != '\0' && str_scan_c == needle_c;
             j++) {
            match_found |= (needle[j + 1] == '\0');
        }
    }
    return match_found ? match_idx : -1;
}
